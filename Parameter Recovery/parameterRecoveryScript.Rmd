---
title: "R Notebook"
output: html_notebook
---


```{r}
library(here)
library(groundhog)
pkgs <- c("ggplot2","optimx","igraph","compiler","lmerTest","truncnorm","rstan")
pacman::p_load(doParallel, parallel, Hmisc)
groundhog.day <- "2023-03-02"
groundhog.library(pkgs, groundhog.day)
here::i_am("./Parameter Recovery/parameterRecoveryScript.Rmd")
source("PR_S_Logistic_1mOppose_Bias.R")
```

# Network

```{r}
posDf <- read.csv("~/Google Drive/Volumes/Research Project/Trait Network_Behaviral/generating network/output/adjacencyMatrix_p.csv")
posMat <- as.matrix(posDf)
posGraph <- graph.adjacency(posMat)
simMat <- similarity.dice(posGraph)
```


```{r}
maxSubjs<- 100
set.seed(52)
#sampTemps <- runif(iter, min=.5, max=9) #rtruncnorm(iter, a=0, b=10, mean = 5, sd = 1.5)
sampTemps <- rtruncnorm(maxSubjs, a=1, b=9, mean = 6, sd = 1.5)
#sampMs <- runif(iter, min=.1, max=5) # rtruncnorm(iter, a=0, b=10, mean = 5, sd = 1.5)
sampMs <- rtruncnorm(maxSubjs, a=.1, b=5, mean = 1.5, sd = 1)
sampBiass <- rtruncnorm(maxSubjs, a=.1, b=.9, mean = .5, sd = .15)

origParams <- data.frame(temp=sampTemps,m=sampMs,bias=sampBiass)
```

```{r}
maxSubjs<- 250
set.seed(52)
#sampTemps <- runif(iter, min=.5, max=9) #rtruncnorm(iter, a=0, b=10, mean = 5, sd = 1.5)
sampTemps <- rtruncnorm(maxSubjs, a=1, b=9, mean = 7.5, sd = .5)
#sampMs <- runif(iter, min=.1, max=5) # rtruncnorm(iter, a=0, b=10, mean = 5, sd = 1.5)
sampMs <- rtruncnorm(maxSubjs, a=.1, b=5, mean = .55, sd = 1)
sampBiass <- rtruncnorm(maxSubjs, a=.1, b=.9, mean = .5, sd = .15)

origParams <- data.frame(temp=sampTemps,m=sampMs,bias=sampBiass)
```


```{r}
selfSimGen <- function(Idx,simMat,coef=30,error=3){
  
curVect <- sample(1:148,1)
simMat[curVect,curVect] <- sort(simMat[curVect,], decreasing = T)[2] # Winsorize the highest value which is a perfect 1, to be second highest value. Perfect 1 screws up min-max scaling
simVect <- simMat[curVect,Idx]
evals <- round(scales::rescale(coef*simVect + rnorm(length(Idx),0,error), to=c(1,7)))
return(list("evals"=evals,"cor"=cor(evals,simVect)))

}


rnorm_pre <- function (x, mu=0, sd=1, r=0, empirical = FALSE, threshold = 1e-12) {
  # error checking
  if (is.vector(x)) x <- data.frame(x)
  #if (!is.numeric(x)) stop("x must be numeric")
  if (nrow(x) < 3) stop("x must have length > 2")
  
  n <- nrow(x)
  d <- ncol(x)
  rho <- rep(r, length.out = d)

  # https://stats.stackexchange.com/questions/15011/generate-a-random-variable-with-a-defined-correlation-to-an-existing-variables
  # answer by https://stats.stackexchange.com/users/919/whuber
  
  # Process the arguments.
  if (is.data.frame(x)) x <- as.matrix(x)
  x <- scale(x) # Makes computations simpler
  y <- stats::rnorm(n)
  
  # Remove the effects of `x` on `y`.
  e <- stats::residuals(stats::lm(y ~ x))
  
  if (d == 1) {
    z <- z <- rho * scale(x)[,1] + sqrt(1 - rho^2) * 
      scale(e)[,1]
  } else {
    # Calculate the coefficient `sigma` of `e` 
    # so that the correlation of `x` with the linear combination 
    # x.dual %*% rho + sigma*e is the desired vector.
    x.dual <- with(svd(x), (n-1)*u %*% diag(ifelse(d > 0, 1/d, 0)) %*% t(v))
    sigma2 <- c((1 - rho %*% stats::cov(x.dual) %*% rho) / stats::var(e))
    
    # Return this linear combination.
    if (sigma2 >= 0) {
      sigma <- sqrt(sigma2) 
      z <- x.dual %*% rho + sigma*e
    } else {
      warning("Correlations are impossible.")
      z <- rep(0, n)
    }
  }
  
  as.vector(mu + sd * z)
}

selfSimGen2 <- function(Idx, simMat, mu=4, sd=2, r=.7){
  curVect <- sample(1:148,1)
  simMat[curVect,curVect] <- sort(simMat[curVect,], decreasing = T)[2] # Winsorize the highest value which is a perfect 1, to be second highest value. Perfect 1 screws up min-max scaling
  simVect <- simMat[curVect,Idx]
  evals <- round(scales::rescale(rnorm_pre(simVect, mu = mu, sd = sd, r=.7),to=c(1,7)))
  return(list("evals"=evals,"cor"=cor(evals,simVect)))
}
```


```{r}
set.seed(100)
maxTrials=148
maxTrain=91

subList <- list()

here::i_am("./Study 1/Computational Model/SA1_Modeling_Final.R")
traindf <- read.csv(here("Study 1/Cleaning/output/fullTrain.csv"))
traindf <- traindf[!is.na(traindf$selfResp),]

for(n in 1:maxSubjs){
  
  #self=round(runif(maxTrain,min=1,max=7))
  
  #self = selfSimGen2(trainIdx,simMat)
  
  subDf <- subset(traindf, subID==sample(unique(fulldf$subID),1))
  evals <- subDf$selfResp
  trainIdx <- subDf$Idx
  
  #trainIdx=sample(1:148,91)
  testIdx=sample(1:148)
  choices <- PR_S_Logistic_1mOppose_Bias(evals, trainIdx, testIdx, simMat, as.numeric(origParams[n,]))
  
  curSubList <- list(evals, trainIdx, testIdx, choices)
  
  subList[[n]] <- curSubList
  
}
```


```{r}
uIds<-1:maxSubjs


groupChoice=array(0,c(maxSubjs, maxTrials))
lengthArray <- matrix(nrow=maxSubjs)
lenTrain <- matrix(nrow=maxSubjs)
prevSim=array(0,c(maxSubjs,maxTrials,maxTrain))
prevSelf=array(0,c(maxSubjs,maxTrain))

for(i in 1:maxSubjs ){
  t <- maxTrials
  lengthArray[i] <- maxTrials
  groupChoice[i,1:t]<- subList[[i]][[4]]
  
  #lenTrain[i] <- maxTrain
  lenTrain[i] <- length(subList[[i]][[1]])
  
  prevSelf[i,1:lenTrain[i]] <- subList[[i]][[1]]
  trainIdx <- subList[[i]][[2]]
  testIdx <- subList[[i]][[3]]
  
  for(trial in 1:t){
    
    curIdx <- testIdx[trial]
    curSims <- simMat[trainIdx, curIdx]
    prevSim[i,trial,1:lenTrain[i]]=curSims
    

    
  }
  
}

model_data <- list( nSubjects=maxSubjs,
                    maxTrials = maxTrials,
                    nTrials = as.numeric(lengthArray),
                    groupChoice = groupChoice,
                    prevSelf=prevSelf,
                    prevSim=prevSim,
                    maxTrain=91,
                    nTrain=as.numeric(lenTrain))


```


# Recovery - Uncorrelated/Random Parameters

```{r}
iter=2000
warmup=floor(iter/2)
modelFile <- here("Computational Models/S_Logistic_1mOppose_Bias.stan")
cores<-detectCores()
S_Logistic_1mOppose_Biasfit <- stan(modelFile, data = model_data, iter = iter, warmup = warmup, cores = cores-1, seed = 52, chains = 3)#, control = list(max_treedepth = 12, adapt_delta = 0.95))
traceplot(S_Logistic_1mOppose_Biasfit)
S_Logistic_1mOppose_Bias_summary <- summary(S_Logistic_1mOppose_Biasfit, pars = c("tau", "m", "bias"), probs = c(0.1, 0.9))$summary
print(S_Logistic_1mOppose_Bias_summary)
get_posterior_mean(S_Logistic_1mOppose_Biasfit, pars=c('tau', 'm', 'bias'))[,4]
S_Logistic_1mOppose_Biasparams <- data.frame(Temp=get_posterior_mean(S_Logistic_1mOppose_Biasfit, pars=c('tau'))[,4],
                                           m=get_posterior_mean(S_Logistic_1mOppose_Biasfit, pars=c('m'))[,4],
                                           bias=get_posterior_mean(S_Logistic_1mOppose_Biasfit, pars=c('bias'))[,4],
                                           LL=get_posterior_mean(S_Logistic_1mOppose_Biasfit, pars=c('log_lik'))[,4])
```

# Generate cormat for original parameters

```{r}
RecovSimparams <- S_Logistic_1mOppose_Biasparams

simDf<-data.frame(origTemp = origParams$temp, 
                  origM = origParams$m, 
                  origBias = origParams$bias, 
                  fitTemp = RecovSimparams$Temp, 
                  fitM = RecovSimparams$m, 
                  fitBias = RecovSimparams$bias)

CorMat_GraphMixRecov <- rcorr(as.matrix(simDf))

cormat <- round(CorMat_GraphMixRecov$r,2)
cormat <- cormat[1:3,4:6]
library(reshape2)
melted_cormat <- melt(cormat)
  get_lower_tri<-function(cormat){
    cormat[upper.tri(cormat)] <- NA
    return(cormat)
  }
  # Get upper triangle of the correlation matrix
  get_upper_tri <- function(cormat){
    cormat[lower.tri(cormat)]<- NA
    return(cormat)
  }
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}

upper_tri <- get_upper_tri(cormat)
# Melt the correlation matrix
melted_cormat <- melt(upper_tri, na.rm = TRUE)

# Create a ggheatmap
ggheatmap <- ggplot(melted_cormat, aes(Var2, Var1, fill = value))+
 geom_tile(color = "white")+
 scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
   midpoint = 0, limit = c(-1,1), space = "Lab", 
    name="Pearson\nCorrelation") +
  theme_minimal()+ # minimal theme
 theme(axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 25, hjust = 1), axis.text.y = element_text( 
    size = 25) )+
 coord_fixed()

greekLab <- c(expression(beta), expression(alpha), expression(gamma) )

FitSimHeatMap <- ggheatmap + 
geom_text(aes(Var2, Var1, label = value), color = "black", size = 4) +
theme(
  axis.title.x = element_text(size=18, face="bold"),
  axis.title.y = element_text(size=18, face="bold"),
  panel.grid.major = element_blank(),
  panel.border = element_blank(),
  panel.background = element_blank(),
  axis.ticks = element_blank(),
  legend.justification = c(1, 0),
  legend.position = c(0.48, 0.7),
  legend.direction = "horizontal")+
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                title.position = "top", title.hjust = 0.5)) + xlab("Fitted") + ylab("Simulated") +
  scale_x_discrete(
        labels=greekLab)  +
  scale_y_discrete(
        labels=greekLab)
FitSimHeatMap
```
